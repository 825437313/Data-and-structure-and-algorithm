<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<script>
    // append(element) 向链表尾部追加一个新元素。
    // insert(position, element) 向链表的指定位置插入一个新元素。
    // getElement(position) 获取指定位置的元素。
    // indexOf(element) 返回元素在链表中的索引。如果链表中没有该元素就返回 -1。
    // update(position, element) 修改指定位置上的元素。
    // removeAt(position) 从链表中的删除指定位置的元素。
    // remove(element) 从链表删除指定的元素。
    // isEmpty() 如果链表中不包含任何元素，返回 trun，如果链表长度大于 0 则返回 false。
    // size() 返回链表包含的元素个数，与数组的 length 属性类似。
    // toString() 由于链表项使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString 方法，让其只输出元素的值。
    // forwardString() 返回正向遍历节点字符串形式。
    // backwordString() 返回反向遍历的节点的字符串形式。
    class LinkedList {
        // 初始链表长度为 0
        length = 0;

        head = null;

        tail = null;

        // 内部类（链表里的节点 Node）
        Node = class {
            data;
            next = null;
            pre = null;
            constructor(data) {
                this.data = data;
            }
        };

        append(element) {
            const newNode = new Node(element)
            if (this.head === null) {
                this.head = newNode;
                this.tail = newNode;
            }
            else {
                this.tail.next = newNode;
                newNode.prev = this.tail;
                this.tail = newNode;
            }

            this.length++;
        }

        insert(position, element) {
            if (position < 0 || position >= this.length) return null;
            const newNode = new Node(element)

            //头部插入

            if (position == 0) {
                if (this.head === null) {
                    this.head = newNode;
                    this.tail = newNode;
                }
                this.head.pre = newNode
                newNode.next = this.head;
                this.head = newNode;
            }

            else if (position === this.length) {
                this.tail.next = newNode;
                newNode.prev = this.tail;
                this.tail = newNode;
            } else {
                //中间插入
                let curNode = this.head;

                let preNode = null;

                let tagIndex = 0;

                while (tagIndex++ < position) {
                    preNode = curNode;
                    curNode = curNode.next;
                }

                // 交换节点信息
                preNode.next = newNode;
                newNode.prev = preNode;

                newNode.next = curNode;
                curNode.prev = newNode;

            }

            this.length++;

            return true;

        }

        getElement(position) {
            if (position < 0 || position >= this.length) return null;
            let cur = this.head;
            let idx = 0;
            while (idx++ < position) {
                cur = cur.next;
            }
            return cur.data;
        }

        // 返回元素在链表中的索引。如果链表中没有该元素就返回 -1。
        indexOf(element) {
            let cur = this.head;
            let idx = 0;
            while (cur) {
                if (cur.data === element) {
                    return idx;
                }
                cur = cur.next;
                idx++;
            }
            return -1;

        }

        // update(position, element) 修改指定位置上的元素。
        update(position, element) {

            if (position < 0 || position > this.length) return false;
            let idx = 0;
            let cur = this.head;
            while (idx++ < position) {
                cur = cur.next;
            }
            cur.data = element;
            return true;

        }

        // removeAt(position) 从链表中的删除指定位置的元素。
        removeAt(position) {
            if (position < 0 || position > this.length) return false;
            // 2、根据不同情况删除元素
            let currentNode = this.head;
            if (position === 0) {
                if (this.length === 1) {
                    this.head = null;
                    this.tail = null;
                } else {
                    this.head = this.head.next;
                    this.head.prev = null;
                }
            }
            else if (position === this.length - 1) {
                currentNode = this.tail;
                this.tail.prev.next = null;
                this.tail = this.tail.prev;
            }
            else {
                let idx = 0;
                let pre = null;
                let cur = this.head;
                while (idx++ < position) {
                    pre = cur;
                    cur = cur.next;
                }

                pre.next = cur.next;
                cur.next.pre = pre;
            }
            return currentNode.data;
        }
    }


    const linkedList = new LinkedList();
    // 测试 append 方法
    linkedList.append("AA");
    linkedList.append("BB");
    linkedList.append("CC");
    console.log(linkedList);
    // 测试 toString 方法
    console.log(linkedList.toString()); //-->AA BB CC
    // 测试 insert 方法
    linkedList.insert(0, "123");
    linkedList.insert(2, "456");
    console.log(linkedList.toString()); //--> 123 AA 456 BB CC
    // 测试 getData 方法
    console.log(linkedList.getData(0)); //--> 123
    console.log(linkedList.getData(1)); //--> AA
    // 测试 indexOf 方法
    console.log(linkedList.indexOf("AA")); //--> 1
    console.log(linkedList.indexOf("ABC")); //--> -1
    // 测试 update 方法
    linkedList.update(0, "12345");

    console.log(linkedList.toString()); //--> 12345 AA 456 BB CC
    const data = linkedList.update(1, "54321");
    console.log(linkedList.toString()); //--> 12345 54321 456 BB CC
    console.log(data, "updateReturn");

    // 测试 removeAt 方法
    linkedList.removeAt(3);
    console.log(linkedList.toString()); //--> 12345 54321 456 CC



</script>

<body>

</body>

</html>